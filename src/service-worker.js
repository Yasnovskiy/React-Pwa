/* eslint-disable no-restricted-globals */
// /// <reference lib="webworker" />
// /* eslint-disable no-restricted-globals */

// // This service worker can be customized!
// // See https://developers.google.com/web/tools/workbox/modules
// // for the list of available Workbox modules, or add any other
// // code you'd like.
// // You can also remove this file if you'd prefer not to use a
// // service worker, and the Workbox build step will be skipped.

// import { CacheableResponsePlugin } from 'workbox-cacheable-response';
// import { clientsClaim } from 'workbox-core';
// import { ExpirationPlugin } from 'workbox-expiration';
// import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
// import { registerRoute } from 'workbox-routing';
// import { CacheFirst, NetworkFirst, StaleWhileRevalidate } from 'workbox-strategies';

// // declare const self: ServiceWorkerGlobalScope;

// clientsClaim();

// // Precache all of the assets generated by your build process.
// // Their URLs are injected into the manifest variable below.
// // This variable must be present somewhere in your service worker file,
// // even if you decide not to use precaching. See https://cra.link/PWA
// precacheAndRoute(self.__WB_MANIFEST);

// // Set up App Shell-style routing, so that all navigation requests
// // are fulfilled with your index.html shell. Learn more at
// // https://developers.google.com/web/fundamentals/architecture/app-shell
// const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');
// registerRoute(
//   // Return false to exempt requests from being fulfilled by index.html.
//   ({ request, url }) => {
//     // If this isn't a navigation, skip.
//     if (request.mode !== 'navigate') {
//       return false;
//     }

//     // If this is a URL that starts with /_, skip.
//     if (url.pathname.startsWith('/_')) {
//       return false;
//     }

//     // If this looks like a URL for a resource, because it contains
//     // a file extension, skip.
//     if (url.pathname.match(fileExtensionRegexp)) {
//       return false;
//     }

//     // Return true to signal that we want to use the handler.
//     return true;
//   },
//   createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')
// );

// // // An example runtime caching route for requests that aren't handled by the
// // // precache, in this case same-origin .png requests like those from in public/
// // registerRoute(
// //   // Add in any other file extensions or routing criteria as needed.
// //   ({ url }) => url.origin === self.location.origin && url.pathname.endsWith('.png'),
// //   // Customize this strategy as needed, e.g., by changing to CacheFirst.
// //   new StaleWhileRevalidate({
// //     cacheName: 'images',
// //     plugins: [
// //       // Ensure that once this runtime cache reaches a maximum size the
// //       // least-recently used images are removed.
// //       new ExpirationPlugin({ maxEntries: 50 }),
// //     ],
// //   })
// // );

// // registerRoute(
// //   ({ request }) =>  request.destination === 'script' ||
// //                     request.destination === 'style',
// //   new StaleWhileRevalidate()
// // );

// // registerRoute(
// //   ({ request }) => request.destination === 'image',
// //   new CacheFirst({
// //     cacheName: 'images',
// //     plugins: [
// //       new CacheableResponsePlugin({
// //         statuses: [0, 200]
// //       }),
// //       new ExpirationPlugin({
// //         maxEntries: 60,
// //         maxAgeSeconds: 30 * 24 * 60 * 60 // 30 дней
// //       })
// //     ]
// //   })
// // );

// // Кэшируем страницы (`HTML`) с помощью стратегии `Network First` (сначала сеть)
// registerRoute(
//   // проверяем, что запрос - это переход на новую страницу
//   ({ request }) => request.mode === 'navigate',
//   new NetworkFirst({
//     // помещаем все файлы в кэш с названием 'pages'
//     cacheName: 'pages',
//     plugins: [
//       // кэшируем только результаты со статусом 200
//       new CacheableResponsePlugin({
//         statuses: [200]
//       })
//     ]
//   })
// );

// // Кэшируем запросы на получение `CSS`, `JS` и веб-воркеров с помощью стратегии `Stale While Revalidate` (считается устаревшим после запроса)
// registerRoute(
//   ({ request }) => request.destination === 'style' ||
//     request.destination === 'script' ||
//     request.destination === 'worker',
//   new StaleWhileRevalidate({
//     // помещаем файлы в кэш с названием 'assets'
//     cacheName: 'assets',
//     plugins: [
//       new CacheableResponsePlugin({
//         statuses: [200]
//       })
//     ]
//   })
// );

// // Кэшируем изображения с помощью стратегии `Cache First` (сначала кэш)
// registerRoute(
//   // проверяем, что цель запроса - изображение
//   ({ request }) => request.destination === 'image',
//   new CacheFirst({
//     // помещаем файлы в кэш с названием 'images'
//     cacheName: 'images',
//     plugins: [
//       new CacheableResponsePlugin({
//         statuses: [200]
//       }),
//       // кэшируем до 50 изображений в течение 30 дней
//       new ExpirationPlugin({
//         maxEntries: 50,
//         maxAgeSeconds: 60 * 60 * 24 * 30
//       })
//     ]
//   })
// )

// // This allows the web app to trigger skipWaiting via
// // registration.waiting.postMessage({type: 'SKIP_WAITING'})
// self.addEventListener('message', (event) => {
//   if (event.data && event.data.type === 'SKIP_WAITING') {
//     self.skipWaiting();
//   }
// });

// // Any other custom service worker logic can go here.


const version = "0.0.1";
const cacheName = `airhorner-${version}`;

self.addEventListener('install', e => {
  e.waitUntil(
    caches.open(cacheName).then(cache => {
      return cache.addAll([
        `/`,
        `/index.html`,
        `/styles/main.css`,
        `/scripts/main.min.js`,
        `/scripts/comlink.global.js`,
        `/scripts/messagechanneladapter.global.js`,
        `/scripts/pwacompat.min.js`,
        `/sounds/airhorn.mp3`
      ])
          .then(() => self.skipWaiting());
    })
  );
});

self.addEventListener('activate', event => {
  event.waitUntil(self.clients.claim());
});

self.addEventListener('fetch', event => {
  event.respondWith(
    caches.open(cacheName)
      .then(cache => cache.match(event.request, {ignoreSearch: true}))
      .then(response => {
      return response || fetch(event.request);
    })
  );
});